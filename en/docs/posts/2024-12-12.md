# ECS Architecture Pattern (Why I quit my game, Penitence)

Deciding on what to write for my first post, I'd like to talk about a structure I recently dipped my toes into. Hmm.
It is **Entity-Component-System (ECS for short)**.

## 1. How I... found out about it

Early this year, I saw an introduction video for the Bevy engine, which uses the Rust language.
Bevy uniquely does not follow the typical OOP structure (Game Object, Actor...).

**It was the emergence of ECS.**

So, how does ECS work?
First, to understand this, we need to know about **Data**.

## 2. Data Oriented Programming

Try to think of any Object in your head.
Developers familiar with OOP might have thought of various objects like, well, a cat, a dog, Donald Trump, etc.

Well, let's just say we represent a person as an object.

(Hereafter, all example code is because I'm a C++ developer, so be it.)

```cpp
#include <iostream>
#include <string>

class Person{
public:
    // Various constructors...
    // Copy / Move / Assignment operators...
    // And some other weird getter setter blah blah...

    void Walk(){ // Just a walking function
        std::cout << name << "is walking" << std::endl;
    }

protected:
    std::string name; // Name
    float height; // Height
    float weight; // Weight
};
```

Currently, the members of the Person object are name, height, and weight.
The data types are an 8-byte string and two 4-byte floating-point numbers.

Suppose we create a vector to manage military personnel and iterate through it.

```cpp
std::vector<Person> soldiers;

for(const auto& soldier : soldiers)
    soldier.Walk();
```

Then this vector becomes an **Array Of Structure**.

**This is the problem.**

Huh? Isn't it fine? What's the problem? If you ask, of course, it might be comfortable when developing. Because that's the purpose of OOP.
But if someone you might have heard of in Computer Architecture class appears, the story changes!

### It is the Cache.

Let's just take an easy example.

You are now a librarian.
But the books are stuck anywhere regardless of subject, initial, or publication date.
Wouldn't you want to die of annoyance?

The important thing here is not the emotion but the reason.
You need to know where that desire for self-destruction due to annoyance comes from.

Why does it get hard if the books are located wherever they please?
The answer is, you have to move back and forth a hell of a lot.

> I think book S is over there.
> -> Ah, it wasn't. Is it there?
> -> Not there either. Damn.

It becomes like this.
The cache also experiences this situation, and they call it a **Cache Miss**.

And anyone with even a little intelligence would absolutely not manage it like this.
At least, wouldn't you laminate and stick on the front page what field the book is in...

### But, the Cache is the same.

Think carefully.
In computer hardware, *DATA* is ultimately memory space.

Person object's memory can be modeled as follows.

||Person||
|-|-|-|
|name(8 byte)|height(4 byte)|weight(4 byte)|

Now, let's think about iterating through the soldiers vector.
The pointer will point to the 8-byte name at first, and then sequentially height, weight.
Sometimes the pointer has to move 8 bytes, and sometimes it has to move 4 bytes.

Now, due to this method, more resources are wasted in memory reference than you think **(really)**.

### So what should we do?

One of the good ways to solve this problem is,
**To separate the data and logic inside the object.**

Hmm... let's try to make the original code like this.

```cpp
#include <iostream>
#include <string>

// Namespace for easy understanding instead of class
namespace Person{
    std::string Name;
    float Height;
    float Weight;

    void Walk(const Person::Name& name){
        std::cout << name << "is walking" << std::endl;
    }
};

std::vector<std::string> Soldiers;

// Iteration
for(const std::string& name : Soldiers)
    Person::Walk(name);
```

"Uh? Then how do we iterate through height or weight?"
The answer to that question is as follows.

```cpp
#include <unordered_map>

std::unordered_map<std::string, float> SoldierHeights;

void PrintHeight(const std::string& name){
    std::cout << SoldierHeights[name] << std::endl;
}

// Iteration
for(const std::string& name : Soldiers)
    PrintHeight(name);
```

Since it's improvised code, it looks a bit... idiotic, but the core idea is this!

**Liberating data and logic from the prison called Object in this way!**

And making it into a Structure Of Arrays like this,
**Is Data Oriented Programming, Data Oriented Design.**

## 3. So what is ECS?

Hmm... First, let's change what we iterated with Person::name when iterating the soldiers vector above to the following.

```cpp
#include <string>
#include <vector>
#include <unordered_map>

namespace Entity{
    using ID = int;
}

namespace Component{
    using Name = std::string;
    using Height = float;
    using Weight = float;
};

namespace System{
    std::unordered_map<Entity::ID, Component::Name> Names;
    
    auto Walk = [&](Entity::ID id){
        std::cout << Names[id] << "is walking\n";
    };
}

int main(){
    std::vector<Entity::id> soldiers;

    // Roughly entity initialization code ~~~ 
    for(const int id : soldiers)
        System::walk(id);
}
```

Looking at the code above, do you see traces of the Person object?
Unless you know that we modified Person like us,
It will probably be hard to find.

The hint is already in the code.

### Entity is the minimum ID that can identify specific data.
I expressed id as int in the code above.

I think I can now talk about my growth project, 'Penitence',
which I **intended** to be with every part of development starting from the engine. [(Project Link)](https://github.com/G1rmmr/penitence-source)

For reference, in Penitence, Entity is defined as follows.

```cpp
#include <cstdint>

namespace MIR{ // Engine Name
    namespace ECS{ // Group related to ECS Architecture
        struct Entity{ // Actually, using namespace might have been fine...{
            using ID = uint16_t;
        };
    }
}
```

### Component is data.

Now, I explained that DOP separates **data** and logic.
The data mentioned there is called a **Component** in ECS.

If you are a commercial engine game developer, you probably know the concept of components well, that's right.

Hmm... since we're talking about it,
The game structure flow with ECS applied goes roughly like this.

|Game Init|Game Update|Game Shutdown|
|-|-|-|
|Set Entity ID|Apply System to Components|Release Dynamically Allocated Memory|
|Set Component Initial Values|Save Components Updated by System|(And this and that)|

In my case, the component structure is unique.
(Warning: Code is cryptic.)

```cpp
// Component Base Class
namespace MIR{
    constexpr std::uint8_t MAX_COMPONENTS = 0xFF;
    
    struct Component{
        using Tag = std::uint32_t;
        
        virtual ~Component() = default;
    };
}
```

```cpp

namespace MIR{
    // Pool Base Class
    class PoolBase{
    public:
        virtual ~PoolBase() = default;
    };

    // Component Pool
    template <typename T>
    class ComponentPool : public PoolBase{
    public:
        static constexpr std::size_t MAX_SIZE = 0xFF;

        ComponentPool() = default;

        template <typename... Args>
        inline std::unique_ptr<Component, std::function<void(Component*)>> 
            Acquire(Args&&... args){
            T* component;

            if(pool.empty()){
                // No spare component in pool, so allocate new component
                component = new T(std::forward<Args>(args)...);
            }
            else{
                // Reuse existing component
                component = pool.top();
                pool.pop();

                // Re-initialize with new arguments
                *component = T(std::forward<Args>(args)...);
            }

            // Define custom deleter: called when unique_ptr is released
            auto deleter = [this](Component* ptr){
                this->Release(static_cast<T*>(ptr));
            };

            return std::unique_ptr<Component,
                std::function<void(Component*)>>(component, deleter);
        }

    private:
        std::stack<T*> pool;

        inline void Release(T* component){
            if(component){
                if(pool.size() < MAX_SIZE) pool.push(component);
                else delete component;
            }
        }
    };
};
```

This is my way of managing components so far.

I thought about using type_info, index comfortably when managing Components,
but adopted a similar method, just like differentiating entities by ID. (However, since the name ID overlaps with Entity::ID and can be confusing, I defined a new identifier called Tag.)

Also, I made the component pool using a stack to maximize cache friendliness.

Below is the manager class. (More cryptic)

```cpp
namespace MIR{
    namespace ECS{
        using Mask = std::bitset<MAX_COMPONENTS>;

        using Data = std::unordered_map<Component::Tag,
            std::unique_ptr<Component, std::function<void(Component*)>>>;

        using Pool = std::shared_ptr<PoolBase>;

        class Manager{
        public:
            Manager() = default;
            ~Manager();

            Entity::ID CreateEntity();
            void DestoryEntity(Entity::ID id);

            template <typename T, typename... Args>
            requires std::constructible_from<T, Args...>
            inline void AddComponent(Entity::ID id, Args&&... args){
                if(masks.find(id) == masks.end())
                    throw std::runtime_error("Invalid Entity ID");

                Component::Tag tag = GetTag<T>();
                if(masks[id][tag])
                    throw std::runtime_error("Component already exists for this Entity");
                
                masks[id].set(tag);

                if(pools.find(tag) == pools.end())
                    pools[tag] = std::make_shared<ComponentPool<T>>();

                auto pool = std::static_pointer_cast<ComponentPool<T>>(pools[tag]);
                auto component = pool->Acquire(std::forward<Args>(args)...);
                components[id][tag] = std::move(component);
            }

            template <typename T>
            inline T* GetComponent(Entity::ID id){
                Component::Tag tag = GetTag<T>();
                if(!masks[id][tag]) return nullptr;

                auto it = components.find(id);

                if(it != components.end() && it->second.find(tag) != it->second.end())
                    return static_cast<T*>(it->second[tag].get());

                return nullptr;
            }

            template <typename T>
            inline bool HasComponent(Entity::ID id){
                Component::Tag tag = GetTag<T>();
                return masks[id][tag];
            }

            template <typename... Components>
            inline std::vector<Entity::ID> Query() const{
                std::vector<Entity::ID> result;

                for(const auto& [id, mask] : masks){
                    if((mask.test(GetTag<Components>()) && ...))
                        result.emplace_back(id);
                }
                return result;
            }

        private:
            /// Map managing component data per entity
            std::unordered_map<Entity::ID, Data> components;
            /// Map managing component possession mask per entity
            std::unordered_map<Entity::ID, Mask> masks;
            /// Map managing pools per component tag
            std::unordered_map<Component::Tag, Pool> pools;

            /// Queue managing reusable entity IDs
            std::queue<Entity::ID> id_queue;
            
            /// Next entity ID to allocate
            inline static Entity::ID next_id = 0;
            /// Next component tag to allocate
            inline static Component::Tag next_tag;

            inline Entity::ID GetID(){
                return next_id++;
            }
            
            template <typename T>
            inline static Component::Tag GetTag(){
                static Component::Tag tag = next_tag++;
                return tag;
            }
        };
    }
}
```

Wow, looking at it now, the code gives me goosebumps.

Mask <<<< **This is the GOAT of my ideas.**

When updating systems, checking the status of entities and iterating through them one by one with Tags feels too annoying...
So one of the things I thought of is as follows.

**'If we guarantee that an entity 'must' have a few components to be updated in a specific system, don't we not need to check all entities?'**

Like that, I made a structure called Mask, and a template function called Query().

The feature of Query() is returning an entity vector that has all components passed inside the parameter pack.
And that operation works fast with bitsets, and I 'think' the person reading the code can easily(?) understand what role the code plays.

Anyway, now the next topic.

### System is logic.

I think I already explained more than half about the system in components.

Let's just understand by looking at the code.

```cpp
namespace MIR{
    class System{
    public:
        System() = default;
        virtual ~System() = default;
        
        virtual void Update(ECS::Manager& manager, const float dt) = 0;
    };
}
```

It acquires ECS::Manager through dependency injection to get entities in Update.

To understand a bit more about how it works, let's look at the code I wrote one more time.

```cpp
const float JUMP_SPEED = 500.f;  ///< Ascending speed when jumping
const float GRAVITY = 980.f;     ///< Gravitational acceleration (Unit: pixels/secÂ² assumed)
const float LEVEL = 500.f;       ///< Ground level (y coordinate)

void Movement::Update(Manager& manager, const float dt){
    std::vector<Entity::ID> entities = manager.Query<Position, Velocity, PlayerState, Sprite>();

    for(const auto& id : entities){
        Position* pos = manager.GetComponent<Position>(id);
        Velocity* vel = manager.GetComponent<Velocity>(id);
        PlayerState* state = manager.GetComponent<PlayerState>(id);
        Sprite* spr = manager.GetComponent<Sprite>(id);
        
        // Jump Logic: Process jump command when not in jumping state and on the ground
        if(state->now_state == PlayerState::Jumping
            && !state->is_jumping && pos->y >= LEVEL){
            vel->y = -JUMP_SPEED;
            state->is_jumping = true;
        }

        // Adjust horizontal movement speed and sprite scale according to state
        switch(state->now_state){
        case PlayerState::MovingLeft:
            vel->x = -200.f;
            spr->sprite.setScale(-0.5f, 0.5f);
            break;

        case PlayerState::MovingRight:
            vel->x = 200.f;
            spr->sprite.setScale(0.5f, 0.5f);
            break;

        case PlayerState::Jumping:
            printf("JUMP\n");
            // No special horizontal change during jump, vel->x is maintained (basically 0)
            break;

        default:
            // Horizontal speed 0 in Idle state, etc.
            vel->x = 0.f;
            break;
        }

        // Apply Gravity: Apply gravitational acceleration if not on ground (during jump)
        if(pos->y < LEVEL) vel->y += GRAVITY * dt;

        // Ground Arrival Processing: Correct position, state so as not to cross the ground
        if(pos->y + vel->y * dt >= LEVEL){
            pos->y = LEVEL;
            vel->y = 0.f;
            state->is_jumping = false;

            // Switch to Idle state when reaching ground from jumping state
            if(state->now_state == PlayerState::Jumping)
                state->now_state = PlayerState::Idle;
        }

        // Update Position: Reflect speed * time(dt) to position
        pos->x += vel->x * dt;
        pos->y += vel->y * dt;
    }
}
```

As I continued moving towards the completion of the engine rather than the completion of the game... ha
The code is a bit questionable, but the core idea is as follows.

1. Get entities with a query.
2. Update components according to the situation.

**That's it. Yeah.**

This is how I tried making ECS.

## 4. Pros and Cons
I will summarize the representative pros and cons of the ECS structure as follows.

||Pros & Cons|
|-|-|
|Pros|Good for large-scale simulation, good for parallel programming|
|Cons|Learning curve, if initial design is wrong, GG|

Do I need to explain pros and cons separately?

Since it fetches only components of constant size when iterating objects, cache misses occur less.
Therefore, it is good for large-scale simulations.

Since it uses SOA (Structure of Arrays), it is good for parallel programming.

Cons, no need to say separately, doesn't the answer come out when looking at the code?
It's code at a level that can be understood only if you know a little about C++ and game engine structure.

Anyway, let's say so.

## 5. Why did you give up Penitence? Persistence tsk tsk

Originally, the significance of the _Penitence_ project was as follows.

1. Try making ECS structure
2. Make a 2D game

Overall, leveling up Cpp code writing was my goal. That's what I mean.

But, while making this... MIR engine... it's too charming...
My passion for making Penitence cooled down.

### But in conclusion, it is scheduled to be made in a different way.

Not as a standalone type game,
**A demo concept game that can show off the new features of the engine whenever the version of the MIR engine is upgraded**
I think it will come out this way.

_(Actually, it's too wasteful to discard the concept of Penitence... ;;;)_

Ah, I admit I have no persistence....

I have absolutely nothing to say about that...


## 6. Wrap-up

In the first post, I introduced the engine I made, MIR.
Probably, I think MIR will be renewed in a different way (Modern, abandoning C++ haha)!

Now it's 2025, HNY everyone

```