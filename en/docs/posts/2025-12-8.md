# Recent Update and MIR 2.0

## 1. After Smashing all Graphics APIs posted in January,

Really really really I was in the process of mastering DX11.
I was doing something reckless like making a [FPS natively](https://github.com/G1rmmr/dx-tutorial).

**Then I got a job as a Windows developer! (Oh yeah!)**


## 2. Even while working for a few months, I am making a game to keep my identity.

So... I am making [this](https://github.com/G1rmmr/art-gallery-ghost-cmake)!

## 3. MIR 2.0 is under development.

MIR 2.0, which will be upgraded this time, has the following features.

1. **Full Array Component**  
The MIR 1.0 version made before was, how should I say... too wishy-washy.
I said I used arrays to increase cache friendliness... but I was using maps more.
So this time, based on namespaces, I manage all elements of components as arrays accessible by id.
```cpp
namespace transform{
    static inline std::array<sf::Vector2f, MAX_ENTITIES> Positions;
    static inline std::array<sf::Vector2f, MAX_ENTITIES> Velocities;
    static inline std::array<sf::Vector2f, MAX_ENTITIES> Scales;
    static inline std::array<float, MAX_ENTITIES> Rotations;
    
    static inline void Clear(){
        for(ID id = 1; id < MAX_ENTITIES; ++id){
            if(!entity::IsAvailables[id]) continue;
    
            Positions[id] = sf::Vector2f(0.f, 0.f);
            Velocities[id] = sf::Vector2f(0.f, 0.f);
            Scales[id] = sf::Vector2f(0.f, 0.f);
            Rotations[id] = 0.f;
        }
    }
}
``` 
Like the structure above, now all components are simple arrays, so you can fetch everything by ID.
  
2. **Full Header Framework**  
MIR 2.0 provides all functions as headers except for special classes.  
By being provided as headers, I could offset the hassle in CMake builds.  
Not only that, all functions are declared inline in the header.  
However, you must be careful about circular references in this process.  
Compilation errors may occur unintentionally.  
  
3. **Better Event System**  
The previous event system was too disorganized.
Currently, I implemented an event bus system so that you can subscribe and unsubscribe at any time.
```cpp
namespace{
    using SubID = std::size_t;

    class Base{
    public:
        Base() = default;
        Base(const Base& other) = default;
        Base& operator=(const Base& other) = default;

        Base(Base&& other) noexcept = default;
        Base& operator=(Base&& other) noexcept = default;

        virtual ~Base() = default;
    };

    template<typename T>
    class Listener : public Base{
    public:
        explicit Listener(std::function<void(const T&)> callBack)
            : callback(std::move(callBack)) {}
        
        void Exec(const T& event){ callback(event); }

    private:
        std::function<void(const T&)> callback;
    };

    static inline std::unordered_map<std::type_index,
    std::unordered_map<SubID, std::unique_ptr<Base>>> Listeners;

    static inline SubID NextID = 0;
}
```
4. **Type Wrapper**  
For developers unfamiliar with C++ types, I wrapped types with more intuitive naming.
```cpp
namespace mir {
    template<typename T>
    using List = std::vector<T>;

    template<typename K, typename V>
    using Dictionary = std::unordered_map<K, V>;

    template<typename T>
    using Queue = std::queue<T>;

    template<typename T>
    using Stack = std::stack<T>;

    template<typename... TArgs>
    using Action = std::function<void(TArgs...)>;

    template<typename TReturn, typename... TArgs>
    using Func = std::function<TReturn(TArgs...)>;

    template<typename T>
    using Point2 = sf::Vector2<T>;

    template<typename T>
    using Rect = sf::Rect<T>;

    using Int = std::int32_t;
    using Uint = std::uint16_t;
    using Real = float;
    using Bool = bool;
    using String = std::string;
    using Color = sf::Color;
    using Texture = sf::Texture;
    using Sprite = sf::Sprite;
    using Sound = sf::Sound;
    using Music = sf::Music;
    using Font = sf::Font;
    using Text = sf::Text;

    static constexpr Int I_MAX = std::numeric_limits<Int>::max();
    static constexpr Int I_MIN = std::numeric_limits<Int>::min();
    static constexpr Uint U_MAX = std::numeric_limits<Uint>::max();
    static constexpr Uint U_MIN = std::numeric_limits<Uint>::min();
    static constexpr Real R_MAX = std::numeric_limits<Real>::max();
    static constexpr Real R_MIN = std::numeric_limits<Real>::min();
}
```

## 4. Well... I am making Art Gallery Ghost using MIR 2.0 made with additional features like above.

## 5. Please give it a lot of interest!